<html>

<body>

    <script src="js/third_party/babylon.js/babylon.2.5.max.js"></script>
    <script type='text/javascript'>
        var Module = {};

        function downloadWasm(url) {
            return new Promise(function (resolve, reject) {
                var wasmXHR = new XMLHttpRequest();
                wasmXHR.open('GET', url, true);
                wasmXHR.responseType = 'arraybuffer';
                wasmXHR.onload = function () { resolve(wasmXHR.response); }
                wasmXHR.onerror = function () { reject('error ' + wasmXHR.status); }
                wasmXHR.send(null);
            });
        }

        var wasm = downloadWasm('../build/artoolkit_wasm.wasm');

        // Module.instantiateWasm is a user-implemented callback which the Emscripten runtime calls to perform
        // the WebAssembly instantiation action. The callback function will be called with two parameters, imports
        // and successCallback. imports is a JS object which contains all the function imports that need to be passed
        // to the Module when instantiating, and once instantiated, the function should call successCallback() with
        // the WebAssembly Instance object.
        // The instantiation can be performed either synchronously or asynchronously. The return value of this function
        // should contain the exports object of the instantiated Module, or an empty dictionary object {} if the
        // instantiation is performed asynchronously, or false if instantiation failed.
        Module.instantiateWasm = function (imports, successCallback) {
            console.log('instantiateWasm: instantiating synchronously');
            wasm.then(function (wasmBinary) {
                console.log('wasm download finished, begin instantiating');
                var wasmInstantiate = WebAssembly.instantiate(new Uint8Array(wasmBinary), imports).then(function (output) {
                    console.log('wasm instantiation succeeded');
                    successCallback(output.instance);
                }).catch(function (e) {
                    console.log('wasm instantiation failed! ' + e);
                });
            });
            return {}; // Compiling asynchronously, no exports.
        }
    </script>
    <script src="../build/artoolkit_wasm.js"></script>
    <script src="../js/artoolkit.api.js"></script>

    <canvas id="renderCanvas"></canvas>
    <video id="v" src="Data/output_4.mp4" width="320" height="240" loop="" controls="" autoplay webkit-playsinline></video>

    <script>
        window.addEventListener('artoolkit-loaded', () => {
            var v = document.getElementById('v');

            // get the canvas DOM element
            var canvas = document.getElementById('renderCanvas');
            canvas.height = v.height;
            canvas.width = v.width;

            // load the 3D engine
            var engine = new BABYLON.Engine(canvas, true);
            engine.setSize(v.width, v.height);

            var markerRoot;
            var camera;

            // createScene function that creates and return the scene
            var createScene = function () {
                // create a basic BJS Scene object
                var scene = new BABYLON.Scene(engine);
                scene.useRightHandedSystem = true;

                camera = new BABYLON.Camera('camera1', new BABYLON.Vector3(0, 0, 0), scene);

                camera.attachControl(canvas, true);
                window.camera = camera;

                markerRoot = new BABYLON.AbstractMesh('markerRoot', scene);

                markerRoot.wasVisible = false;
                markerRoot.markerMatrix = new Float64Array(12);

                // create a basic light, aiming 0,1,0 - meaning, to the sky
                var light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0, 1, 0), scene);

                // create a box
                var box = BABYLON.Mesh.CreateBox('box1', 1, scene);
                //set the marker object as box parent
                box.parent = markerRoot;

                // return the created scene
                return scene;
            };

            // call the createScene function
            var scene = createScene();

            var arController = null;

            // run the render loop
            engine.runRenderLoop(function () {
                if (!arController) {
                    return;
                }
                arController.process(v);
                //arController.detectMarker();
                var markerNum = arController.getMarkerNum();
                // console.log(markerNum);

                if (markerNum > 0) {
                    
                    
                } else {
                    //markerRoot.isVisible = false;
                    markerRoot.getChildMeshes().forEach(function (mesh) {
                        //mesh.isVisible = false;
                    });
                }

                arController.debugDraw();

                scene.render();
            });


            var cameraParam = new ARCameraParam();
            cameraParam.onload = function () {

                arController = new ARController(320, 240, cameraParam);
                arController.debugSetup();

                 arController.addEventListener('getMarker', function(ev) {
                    console.log("Detected marker with ids:", ev.data.marker.id, ev.data.marker.idPatt, ev.data.marker.idMatrix);
                    // console.log("Marker data", ev.data.marker);
                    // console.log("Marker transform matrix:", [].join.call(ev.data.matrix, ', '));

                    markerRoot.isVisible = true;
                    markerRoot.getChildMeshes().forEach(function (mesh) {
                        mesh.isVisible = true
                    });
                    arController.arglCameraViewRHf(arController.transMatToGLMat(ev.data.matrix), markerRoot._worldMatrix.m);
                });

                //camera.freezeProjectionMatrix(BABYLON.Matrix.FromArray(arController.getCameraMatrix()));
            };
            cameraParam.load('Data/camera_para.dat');


            // the canvas/window resize event handler
            window.addEventListener('resize', function () {
                engine.resize();
            });
        });
    </script>
</body>

</html>